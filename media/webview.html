<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="table.css">
</head>
<body>
  <div id="table-container">
    <table id="tsv-table">
      <!-- Table will be generated by JavaScript -->
    </table>
  </div>
  
  <!-- Context Menu -->
  <div id="context-menu" class="context-menu" style="display: none;">
    <div class="menu-item" onclick="insertRowBefore()">Insert Row Before</div>
    <div class="menu-separator"></div>
    <div class="menu-item" onclick="deleteRow()">Delete Row</div>
    <div class="menu-separator"></div>
    <div class="menu-item" onclick="foldRow()">Fold</div>
    <div class="menu-item" onclick="unfoldRow()">Unfold</div>
    <div class="menu-item" onclick="foldAllDescendants()">Fold All Descendants</div>
    <div class="menu-item" onclick="unfoldAllDescendants()">Unfold All Descendants</div>
  </div>
  
  <script>
    const vscode = acquireVsCodeApi();
    
    // Handle individual cell edit
    function handleCellEdit(event) {
      const input = event.target;
      const row = parseInt(input.dataset.row);
      const col = parseInt(input.dataset.col);
      
      // Send cell edit to provider
      vscode.postMessage({ 
        type: 'cellEdit', 
        data: {
          position: { row, col },
          value: input.value
        }
      });
    }
    
    // Unified keyboard event handler for all cell interactions
    function handleKeyDown(event, rowIndex, colIndex) {
      const input = event.target;
      
      // Special action keys (always take precedence)
      if (event.ctrlKey && event.key === '.') {
        // Ctrl+. : Toggle fold
        vscode.postMessage({
          type: 'toggleFold',
          data: { rowIndex: rowIndex, focusCell: { row: rowIndex, col: colIndex } }
        });
        event.preventDefault();
        return;
      }
      
      if (event.key === 'Enter') {
        // Enter key: Insert row after current row
        vscode.postMessage({
          type: 'insertRow',
          data: { rowIndex: rowIndex, position: 'after' }
        });
        event.preventDefault();
        return;
      }
      
      if (event.ctrlKey && event.key === 'Delete') {
        // Ctrl+Delete: Delete row
        vscode.postMessage({
          type: 'deleteRow',
          data: { rowIndex: rowIndex }
        });
        event.preventDefault();
        return;
      }
      
      if (event.key === 'Backspace' && input.selectionStart === 0) {
        // Backspace at beginning of cell: delete row or remove column
        const currentRow = document.querySelector(`tr[data-original-row="${rowIndex}"]`);
        const cellsInRow = currentRow ? currentRow.querySelectorAll('input').length : 0;
        
        if (cellsInRow === 1 && input.value === '') {
          // Empty line: delete the row
          vscode.postMessage({
            type: 'deleteRow',
            data: { rowIndex: rowIndex }
          });
          event.preventDefault();
          return;
        } else if (input.value === '' && colIndex + 1 >= cellsInRow && cellsInRow > 1) {
          // Last cell of row with multiple cells: remove column
          vscode.postMessage({
            type: 'removeColumn',
            data: { rowIndex: rowIndex, focusCol: colIndex - 1 }
          });
          event.preventDefault();
          return;
        }
      }
      
      // Navigation keys
      let targetRow = rowIndex;
      let targetCol = colIndex;
      let shouldNavigate = false;
      
      switch(event.key) {
        case 'Tab':
          if (event.shiftKey) {
            // Shift+Tab: move left
            targetCol = colIndex - 1;
            shouldNavigate = true;
          } else {
            // Tab: check if we're at the last cell of the row
            const currentRow = document.querySelector(`tr:nth-child(${rowIndex + 1})`);
            const cellsInRow = currentRow ? currentRow.querySelectorAll('input').length : 0;
            
            if (colIndex + 1 >= cellsInRow) {
              // We're at the last cell, add a new column
              vscode.postMessage({
                type: 'addColumn',
                data: { rowIndex: rowIndex, newColIndex: colIndex + 1 }
              });
              event.preventDefault();
              return;
            } else {
              // Normal tab navigation
              targetCol = colIndex + 1;
              shouldNavigate = true;
            }
          }
          break;
          
        case 'ArrowUp':
          targetRow = rowIndex - 1;
          shouldNavigate = true;
          break;
          
        case 'ArrowDown':
          targetRow = rowIndex + 1;
          shouldNavigate = true;
          break;
          
        case 'ArrowLeft':
          // Only navigate if cursor is at start of input
          if (input.selectionStart === 0) {
            targetCol = colIndex - 1;
            shouldNavigate = true;
          }
          break;
          
        case 'ArrowRight':
          // Only navigate if cursor is at end of input
          if (input.selectionStart === input.value.length) {
            targetCol = colIndex + 1;
            shouldNavigate = true;
          }
          break;
      }
      
      if (shouldNavigate) {
        event.preventDefault();
        
        // Find target cell and focus it
        const targetInput = document.querySelector(`[data-row="${targetRow}"][data-col="${targetCol}"]`);
        if (targetInput) {
          targetInput.focus();
          targetInput.select(); // Select all text in the target cell
        }
      }
    }
    
    // Context menu and row operations
    let contextMenuRow = -1;
    
    // Show context menu on right click
    function showContextMenu(event, rowIndex) {
      event.preventDefault();
      contextMenuRow = rowIndex;
      const menu = document.getElementById('context-menu');
      menu.style.display = 'block';
      menu.style.left = event.pageX + 'px';
      menu.style.top = event.pageY + 'px';
    }
    
    // Hide context menu
    function hideContextMenu() {
      document.getElementById('context-menu').style.display = 'none';
    }
    
    // Row operation functions
    function insertRowBefore() {
      vscode.postMessage({
        type: 'insertRow',
        data: { rowIndex: contextMenuRow, position: 'before' }
      });
      hideContextMenu();
    }
    
    function insertRowAfter() {
      vscode.postMessage({
        type: 'insertRow',
        data: { rowIndex: contextMenuRow, position: 'after' }
      });
      hideContextMenu();
    }
    
    function deleteRow() {
      vscode.postMessage({
        type: 'deleteRow',
        data: { rowIndex: contextMenuRow }
      });
      hideContextMenu();
    }
    
    // Enhanced table rendering with folding support
    function renderTable(visibleRows) {
      const table = document.getElementById('tsv-table');
      table.innerHTML = '';
      
      visibleRows.forEach((rowData) => {
        const tr = document.createElement('tr');
        tr.dataset.originalRow = rowData.originalRowIndex;
        
        // Add right-click context menu to row
        tr.addEventListener('contextmenu', (event) => showContextMenu(event, rowData.originalRowIndex));
        
        // Add fold indicator column
        const foldTd = document.createElement('td');
        foldTd.className = 'fold-margin';
        
        if (rowData.isFoldable) {
          const foldIndicator = document.createElement('span');
          foldIndicator.className = 'fold-indicator';
          foldIndicator.dataset.foldable = 'true';
          foldIndicator.dataset.folded = rowData.isFolded ? 'true' : 'false';
          foldIndicator.addEventListener('click', () => toggleFold(rowData.originalRowIndex));
          foldTd.appendChild(foldIndicator);
        }
        
        tr.appendChild(foldTd);
        
        // Add data cells with proper indentation
        rowData.cells.forEach((cellValue, colIndex) => {
          const td = document.createElement('td');
          const input = document.createElement('input');
          input.type = 'text';
          input.className = 'cell-input';
          input.value = cellValue || '';
          input.dataset.row = rowData.originalRowIndex;
          input.dataset.col = colIndex;
          
          // Apply indentation to first cell
          if (colIndex === 0) {
            input.style.paddingLeft = (rowData.indentLevel * 20) + 'px';
          }
          
          // Handle cell edits
          input.addEventListener('input', handleCellEdit);
          
          // Handle keyboard navigation and special keys
          input.addEventListener('keydown', (event) => handleKeyDown(event, rowData.originalRowIndex, colIndex));
          
          td.appendChild(input);
          tr.appendChild(td);
        });
        
        table.appendChild(tr);
      });
    }

    // Folding functions
    function toggleFold(rowIndex) {
      vscode.postMessage({
        type: 'toggleFold',
        data: { rowIndex: rowIndex }
      });
    }

    function foldRow() {
      if (contextMenuRow !== -1) {
        vscode.postMessage({
          type: 'toggleFold',
          data: { rowIndex: contextMenuRow }
        });
      }
      hideContextMenu();
    }

    function unfoldRow() {
      if (contextMenuRow !== -1) {
        vscode.postMessage({
          type: 'toggleFold',
          data: { rowIndex: contextMenuRow }
        });
      }
      hideContextMenu();
    }

    function foldAllDescendants() {
      if (contextMenuRow !== -1) {
        vscode.postMessage({
          type: 'foldAllDescendants',
          data: { rowIndex: contextMenuRow, folded: true }
        });
      }
      hideContextMenu();
    }

    function unfoldAllDescendants() {
      if (contextMenuRow !== -1) {
        vscode.postMessage({
          type: 'foldAllDescendants',
          data: { rowIndex: contextMenuRow, folded: false }
        });
      }
      hideContextMenu();
    }

    // Hide context menu when clicking elsewhere
    document.addEventListener('click', hideContextMenu);
    
    // Listen for messages from provider
    window.addEventListener('message', event => {
      if (event.data.type === 'init' || event.data.type === 'refresh') {
        const { visibleRows, focusCell } = event.data.data;
        renderTable(visibleRows);
        
        // Focus specific cell if requested
        if (focusCell) {
          setTimeout(() => {
            const targetInput = document.querySelector(`[data-row="${focusCell.row}"][data-col="${focusCell.col}"]`);
            if (targetInput) {
              targetInput.focus();
            }
          }, 50); // Small delay to ensure table is rendered
        }
      }
    });
  </script>
</body>
</html>
